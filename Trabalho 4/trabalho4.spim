	.data

crc: .asciiz "\nCRC16­BUYPASS: 0x" # String que acompanhará a saída 		
quebra_linha: .asciiz "\n"  # Variável para quebrar a linha após a saída
buffer: .space 17 # Para pegar 16 bytes do buffer
tabela_ascii: .word 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70

	.text
	
main:
	li $v0, 8 			# Para ler uma string
	la $a0, buffer 			# Para o buffer
	li $a1, 17 			# Tamanho máximo da string de entrada
	move $t0, $a0  #		# Move o conteúdo de $a0 para $t0
	syscall				# Faz a chamada do sistema
		
loop:
	lb $a0, ($t0)			#$ $t0 vai percorre a string
	beq $a0, 0, imprime_crc		# Se $a0 for igual a 0, é porque a string terminou
	
	j crc16

crc16:				
	move $s0, $a0			# $s0 = d
	beq $s0, 10, imprime_crc
# c = $t1 eh o estado
# r = $t2 eh o valor calculado
# p = $t3, s = $t4, t = $t5 sao valores intermediarios	
#	add $t1, $t1, 0
	srl $t6, $t1, 8			# t6 = c >> 8
	xor $t4, $s0, $t6		# s = d ^ (c >> 8)
	and $t4, $t4, 255
	
	srl $t6, $t4, 4			# t6 = s >> 4
	xor $t3, $t4, $t6		# p = s ^ ( s >> 4)
	and $t3, $t3, 255
	
	srl $t6, $t3, 2			# t6 = p >> 2
	xor $t3, $t3, $t6		# p = p ^ (p >> 2)
	and $t3, $t3, 255
	
	srl $t6, $t3, 1			# t6 = p >> 1
	xor $t3, $t3, $t6		# p = p ^ (p >> 1)
	and $t3, $t3, 255
	
	and $t3, $t3, 1			# p = p & 1
	and $t3, $t3, 255
	
	sll $t6, $t4, 1			# t6 = s << 1
	or $t5, $t3, $t6		# t = p | (s << 1)
	and $t5, $t5, 65535
	
	sll $t6, $t1, 8			# t6 = c << 8
	sll $t7, $t5, 15		# t7 = t << 15
	sll $t8, $t5, 1			# t8 = t << 1
	
	xor $t9, $t6, $t7		# t9 = (c << 8) ^ (t << 15)
	xor $t2, $t9, $t5		# r = (c << 8) ^ (t << 15) ^ t
	xor $t2, $t2, $t8		# r = r ^ (t << 1)
	and $t2, $t2, 65535
		
	move $t1, $t2			# c = r
	#li $v0, 1
	#la $a0, ($t4) 			#print pra testar $t4(s)
	#syscall
	
	add $t0, $t0, 1  
	j loop
	
imprime_crc:
	li $v0, 4
	la $a0, crc
	syscall
	
	la $t8, tabela_ascii
	and $t6, $t2, 0xf000 		# t6 = r & 0xf000
	srl $t6, $t6, 12		# t6 = t6 >> 12 # 3*4
	mul $t6, $t6, 4
	add $t8, $t8, $t6
	lw $t7, 0($t8)
		
	li $v0, 11
	la $a0, ($t7) 			
	syscall
	
	la $t8, tabela_ascii
	and $t6, $t2, 0x0f00 		# t6 = r & 0xf000
	srl $t6, $t6, 8			# t6 = t6 >> 8 # 2*4
	mul $t6, $t6, 4
	add $t8, $t8, $t6
	lw $t7, 0($t8)
		
	li $v0, 11
	la $a0, ($t7) 			
	syscall

	la $t8, tabela_ascii
	and $t6, $t2, 0x00f0 		# t6 = r & 0xf000
	srl $t6, $t6, 4			# t6 = t6 >> 4 # 1*4
	mul $t6, $t6, 4
	add $t8, $t8, $t6
	lw $t7, 0($t8)
		
	li $v0, 11
	la $a0, ($t7) 			
	syscall

	la $t8, tabela_ascii
	and $t6, $t2, 0x000f 		# t6 = r & 0xf000
	mul $t6, $t6, 4
	add $t8, $t8, $t6
	lw $t7, 0($t8)
		
	li $v0, 11
	la $a0, ($t7) 			
	syscall
	
	li $v0, 4
	la $a0, quebra_linha
	syscall
		
termina:	
	li $v0, 10			# Para finalizar o programa
	syscall				# Faz a chamada do sistema
