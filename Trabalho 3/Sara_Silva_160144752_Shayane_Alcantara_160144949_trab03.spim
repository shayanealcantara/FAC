	.data
	
invalida: .asciiz "Entrada invalida.\n"  	# Mensagem que será exibida caso a entrada não esteja entre 1 e 32768 
quebra_linha: .asciiz "\n"

	.text
	
main:
	li $v0, 5 				#Leitura de um inteiro
	syscall  				#Faz a chamada do sistema
	
	move $s0, $v0  				#Coloca o conteúdo de $v0 em $s0
	
	slti $t1, $s0, 2 			#Verifica se $s0 é menor que 2 
	bne $t1, $zero, se_invalida  		#Se for menor que 2, desvia para rotina de tratamento de entrada invalida
	
	bge $s0, 32768, se_invalida  		#Verifica se $s0 é maior ou igual a 32768, se for, desvia para rotina que trata entrada invalida
	
fator_2:					# Rotina que verifica se 2 é fator do número
	div $s0, $s0, 2  			# Divide o número por 2
	mfhi $t3         			# Salva o resto da divisão no registrador $t3
	beq $t3, $zero, imprime_2  		# Se o resto for igual 0 então 2 é fator e precisa ser impresso
	
	add $t4, $t4, 3
	add $t5, $t5, 9
	
	j fatores_impares          		# Se 2 não for mais um fator, desvia para rotina de possíveis fatores ímpares
	
imprime_2:					# Rotina para imprimir o número 2 como fator
	li $v0, 1   				# Impressão de um inteiro
	la $a0, 2   				# Imprime 2
	syscall     				# faz a chamada do sistema
	
	li $v0, 4  				# Impressão de string
	la $a0, quebra_linha 			# Imprime quebra linha a cada 2 impresso
	syscall   				# Faz a chamada do sistema
	 
	j fator_2  				# Retorna para fator_2 para verificar se há mais fatores 2 para o número
	
fatores_impares:				# Verifica os possíveis fatores ímpares														
	
	ble  $t5, $s0, d2_menor_igual_n
	
	j se_n_primo
	
se_n_primo:

	slti $t6, $s0, 1
	beq $t6, $zero, imprime_n	
		
imprime_n:					# Rotina para imprimir o número 2 como fator
	li $v0, 1 
	la $a0, ($s0)  				# Impressão de um inteiro
	syscall     				# faz a chamada do sistema
	
	li $v0, 4  				# Impressão de string
	la $a0, quebra_linha 			# Imprime quebra linha a cada 2 impresso
	syscall   				# Faz a chamada do sistema
	
	li $v0, 10  				# Finaliza o programa
	syscall  				# Faz a chamada do sistema
			
d2_menor_igual_n:
	
	div $s0, $s0, $t4 			# Divide o número pelo divisor
	mfhi $t6         			# Salva o resto da divisão no registrador $t6
	beq $t6, $zero, imprime_d  
	
	j verifica_proximo		
			
imprime_d:					# Rotina para imprimir o número 2 como fator
	li $v0, 1 
	la $a0, ($t4)  				# Impressão de um inteiro
	syscall     				# faz a chamada do sistema
	
	div $s0, $s0, $t4
	
	li $v0, 4  				# Impressão de string
	la $a0, quebra_linha 			# Imprime quebra linha a cada 2 impresso
	syscall   				# Faz a chamada do sistema
	
	j fatores_impares
	 		
verifica_proximo:
	
	addi $t4, $t4, 2
	mul $t5, $t4, $t4
	
	j fatores_impares
	 							 													 						
se_invalida:					# Rotina que trata as entrandas inválidas
	li $v0, 4 				# Impressão de string
	la $a0, invalida 			# Imprime "Entrada invalida.\n"
	syscall   				# Faz a chamada do sistema
	
	li $v0, 10  				# Finaliza o programa
	syscall  				# Faz a chamada do sistema